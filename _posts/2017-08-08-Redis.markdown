---
layout: post
title:  "Redis Cache"
date:   2017-08-08 03:19:49 +0100
tags: [Redis,Cache]
author: Temi Lee
---

Redis 在系统中的必要性：对于一个服务其性能瓶颈大多都在DB，DB一般来说是在硬盘上拿数据，而缓存是基于内存，速度更快

<br/>

**那把所有数据都放到内存可以嘛？肯定不行：**
- 内存相比与硬盘来说还比较贵
- 断电或者系统重启后内存数据消失
- Redis更适合将阶段性热点数据缓存在内存中

**redis与传统RDBMS 的区别**
- 存储介质：reids面向的存储介质为内存，RDBMS为硬盘
- 数据结构：redis针对不同的场景有多种数据组织结构(`对普遍存在的操作，使用专门的数据结构组织`)，而RNBMS使用单一数据组织结构——表格。(｀基于表格的存储和管理,可以进行丰富的建模，但是这也带来了缺点：不能做到简单、快速｀)
- 查询：redis仅支持按key查询，对基于值的复杂查询不支持；RDBMS支持基于值的复杂查询
- 应用场景：redis是针对一类作用、组织特殊数据的数据构建的高速查询、存储内存数据库，RDBMS是对数据处理的一种普遍的解决方案


**Redis支持的数据结构:**

|数据结构|存储的值|结构支持的操作|
|:-----:|:-----:|:----------:|
|   STRING |字符串、整数、浮点数|对整个字符串或者字符串的其中一部分执行操作(`GET,SET,APPEND`);对整数和浮点数执行自增（`INCR,INCRBY`）或者自减（`DECR,DECRBY`）操作|
|   LIST   |一个每个节点都包含了一个字符串的链表，元素可以重复,有序的链表|支持链表双端入队或者出队(`LPOP,RPOP,LPUSH,RPUSH`);根据偏移量裁剪链表(`LRANGE O(S+N)`);根据值移除元素(`LREM O(N)`)|
|   SET    |无序、不重复的集合| 元素的添加(`SADD O(N)， N 是被添加的元素的数量。`)、获取(`SPOP O(1)、 SRANDMEMBER O(N) N 为返回数组的元素个数。`)、删除(`SPOP O(1)`)、交集(`SINTER O(N * M) N 为给定集合当中基数最小的集合 M 为给定集合的个数。`、并集(`SUNION O(N)`、差集(`SDIFF O(N)`)|
|   HASH    |包含键值对的无序散列表    |添加(`HSET O(1)`)、获取(`HGET O(1)`)、移除单个键值对(`HDEL O(N) N 为要删除的域的数量`)；获取所有键值对(`HGETALL O(N)`)|
|   SortedSet|有序的集合|添加、获取、删除单个元素；根据分值范围(`ZRANGEBYSCORE O(log(N)+M) N 为有序集的基数 M 为被结果集的基数`)或者成员来获取元素|


[1]: /img/blog/redis/redis_sds.png